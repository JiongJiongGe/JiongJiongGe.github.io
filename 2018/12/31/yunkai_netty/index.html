<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Netty：走一走微信IM即使通讯 | 守得云开见月明 | 在IT海洋打滚的小🐳</title>

  
  <meta name="author" content="云开">
  

  
  <meta name="description" content="在IT海洋打滚的小🐳">
  

  
  
  <meta name="keywords" content="SpringBoot,Netty,NIO">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Netty：走一走微信IM即使通讯"/>

  <meta property="og:site_name" content="守得云开见月明"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="守得云开见月明" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">守得云开见月明</a>
    </h1>
    <p class="site-description">在IT海洋打滚的小🐳</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Netty：走一走微信IM即使通讯</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/12/31/yunkai_netty/" rel="bookmark">
        <time class="entry-date published" datetime="2018-12-31T10:27:43.000Z">
          2018-12-31
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>矫情一下：<br>看了上一次博客，发现已经是半年前了。确实变懒了一些，周末除了解决公司问题，基本上不怎么会开电脑，翻翻书，看看电视，眨眼间周一又到了。不过我还是很庆幸有这样的时光，半年没见了，相信大家提升了不少，云开也没有怠慢哦，经历了公司的六一八、双十一、双十二性能的考验、在书中获取到了不曾了解的知识、对生活的想法也成熟了一些。好了，就矫情到这吧，让我们进入这次的正题，Netty学习。</p>
<h2 id="Netty是谁？"><a href="#Netty是谁？" class="headerlink" title="Netty是谁？"></a>Netty是谁？</h2><p>借助官方的话：Netty是一个异步事件驱动的网络应用框架，用于快读开发可维护的高性能协议服务器和客户端。<br>同时，Netty是一个基于NIO的客户端、服务断框架。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在如今主流的Rpc框架，如：Dubbo，可是有Netty的身影哦，不知道大家是否有留意过，当dubbo服务端未启动时，当客户端去连接/调用的时候，在出现的错误中，会有一些Netty的错误信息，这边就不细讲了，如果有兴趣可以去实践一下。<br>除了dubbo，在Redis底层中，Netty也是其中一个角色噢。这边云开就列了这两个例子，大家也可以搜下资料，看看Netty的其他影子。<br>etc…</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>JDK 1.8.0_131、MAVEN apache-maven-3.5.0</p>
<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>SpringBoot、Mybatis、Zookeeper</p>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>IntelliJ IDEA 2(开发工具大家可以根据自己的喜好而定)</p>
<h3 id="实践过程"><a href="#实践过程" class="headerlink" title="实践过程"></a>实践过程</h3><p>实践的话，我将通过服务端启动、客户端启动、客户端与服务端的通信、维护/断开客户端与服务端通信这四个方面介绍我对Netty的简单实践、理解，如果大家觉得直接阅读代码有些不适，大家可以直接拉到最后知识点介绍，首先开始阅读，然后再回过头来看代码的实现。</p>
<h4 id="服务端启动"><a href="#服务端启动" class="headerlink" title="服务端启动"></a>服务端启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class NettyServerStartRunner implements CommandLineRunner &#123;</span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(NettyServerStartRunner.class);</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private ZKServiceRegistry zkServiceRegistry;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 接收新的客户端链接线程组</span><br><span class="line">         */</span><br><span class="line">        NioEventLoopGroup boss = new NioEventLoopGroup();</span><br><span class="line">        /**</span><br><span class="line">         * 处理每条链接写入的数据线程组</span><br><span class="line">         */</span><br><span class="line">        NioEventLoopGroup worker = new NioEventLoopGroup();</span><br><span class="line">        /**</span><br><span class="line">         * 引导服务端启动工作类</span><br><span class="line">         */</span><br><span class="line">        ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">        serverBootstrap</span><br><span class="line">                //.group 配置线程组</span><br><span class="line">                .group(boss, worker)</span><br><span class="line">                //.channel 指定服务端的IO模型，NioServerSocketChannel为NIO模型</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                //.childHandler 定义后续每条链接的数据读写，NioSocketChannel同理定义NIO模型</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(new IMIdleStateHandler());</span><br><span class="line">                        ch.pipeline().addLast(new Spliter());</span><br><span class="line">                        ch.pipeline().addLast(PacketCodecHandler.INSTANCE);</span><br><span class="line">                        ch.pipeline().addLast(new CreateGroupHandler());</span><br><span class="line">                        ch.pipeline().addLast(IMHandler.INSTANCE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                //指定服务端启动过程中的一些逻辑</span><br><span class="line">                .handler(new ChannelInitializer&lt;NioServerSocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(NioServerSocketChannel serverCh) throws Exception &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                //.childOption开启tcp底层相关的属性，so_keepAlive true 表示底层开启心跳协议</span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">                //.option 服务端设置属性，so_backlog表示系统用于临时存放已完成三次握手的请求队列的最大长度，如果连接建立频繁，可以扩大该值。</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, true);</span><br><span class="line"></span><br><span class="line">        //.addListener 给返回结果ChannelFuture绑定监听器，用户判断端口是否绑定成功</span><br><span class="line">        serverBootstrap.bind(&quot;127.0.0.1&quot;, 8000).addListener(new GenericFutureListener&lt;Future&lt;? super Void&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(Future&lt;? super Void&gt; future) throws Exception &#123;</span><br><span class="line">                if (future.isSuccess()) &#123;</span><br><span class="line">                    logger.info(&quot;端口绑定成功&quot;);</span><br><span class="line">                    if (zkServiceRegistry != null) &#123;</span><br><span class="line">                        zkServiceRegistry.register(&quot;127.0.0.1:8000&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //查看错误数据</span><br><span class="line">                    logger.error(future.cause().getMessage());</span><br><span class="line">                    logger.info(&quot;端口绑定失败&quot;);</span><br><span class="line">                    //失败后可重新绑定</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NettyServerStartRunner类，借助了SpringBoot的CommandLineRunner接口，使得在项目启动时，启动Netty服务端。<br>类内元素说明：<br>1、由于Netty是基于NIO的框架，其线程组的实现原理也与NIO类似，故创建了boss和worker两个线程组，boss线程组用户接受新的客户端链接,worker线程组则处理每条客户端链接的写入。<br>2、serverBootstrap 引导服务端的启动类，在serverBootstrap会配置线程组、服务端的IO类型以及开启相关的属性等，大家可以查看代码中的注释，简单了解下每个元素的作用。这里特别注意两个点：(1)、childHandler()内元素定义了之后的每条客户端链接读写的过程，具体的会在(客户端与服务端的通信)里面详细介绍；(2)、bind方法则为服务端绑定对应的ip地址和端口，并增加了个listener(监听),如果与ip+端口绑定成功后，将此服务端服务注入到zk中。</p>
<h4 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h4><h5 id="NettyClientStartRunner类"><a href="#NettyClientStartRunner类" class="headerlink" title="NettyClientStartRunner类"></a>NettyClientStartRunner类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class NettyClientStartRunner implements CommandLineRunner&#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(NettyClientStartRunner.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ZKServiceDiscovery zkServiceDiscovery;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        ZKServiceDiscovery.zkServiceDiscovery = zkServiceDiscovery;</span><br><span class="line">        zkServiceDiscovery.connectServer();</span><br><span class="line">        zkServiceDiscovery.getNode();</span><br><span class="line">        String serverAddress = zkServiceDiscovery.discover();</span><br><span class="line">        if (!StringUtils.isEmpty(serverAddress)) &#123;</span><br><span class="line">            ZKConstant.ZK_CURRENT_SERVER_NODE = serverAddress;</span><br><span class="line">            String[] addressArr = serverAddress.split(&quot;:&quot;);</span><br><span class="line">            if (addressArr != null &amp;&amp; addressArr.length &gt; 0) &#123;</span><br><span class="line">                ClientConnectUtil.connect(addressArr[0], Integer.parseInt(addressArr[1]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NettyClientStartRunner类，同样借助了SpringBoot的CommandLineRunner接口，使得项目启动时，就让客户端尝试去链接服务端。<br>说明：<br>此处把Netty客户端链接服务端的逻辑抽离成ClientConnectUtil的工具方法的原因是，云开想模拟多个服务端提供服务，当客户端已链接的服务端因为某些原因，例如此服务端被关闭了，客户端能够重新链接新的服务提供者，从而不影响客服端与服务端之间的通讯。上述ClientConnectUtil.connect方法则是从zk中服务端列表中随机拿取一个服务端信息，尝试去链接。</p>
<h5 id="ClientConnectUtil类"><a href="#ClientConnectUtil类" class="headerlink" title="ClientConnectUtil类"></a>ClientConnectUtil类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public class ClientConnectUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(ClientConnectUtil.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 轮询登录，5s一次</span><br><span class="line">     */</span><br><span class="line">    private static final int TIME_LOGIN = 5;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 客户端连接服务端</span><br><span class="line">     */</span><br><span class="line">    public static Channel connect(String host, int port) &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 线程组(线程模型)</span><br><span class="line">         */</span><br><span class="line">        NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line">        /**</span><br><span class="line">         * 客户端启动类，负责启动客户端以及连接服务端</span><br><span class="line">         */</span><br><span class="line">        Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">        bootstrap</span><br><span class="line">                //.group 配置线程组</span><br><span class="line">                .group(workerGroup)</span><br><span class="line">                //.channel 指定IO模型 NioSocketChannel为NIO模型</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                //.handler 定义连接的业务处理逻辑</span><br><span class="line">                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">                        //ch.pipeline()返回和此条连接相关的责任链</span><br><span class="line">                        ch.pipeline().addLast(new IMIdleStateHandler());</span><br><span class="line">                        ch.pipeline().addLast(new Spliter());</span><br><span class="line">                        ch.pipeline().addLast(PacketCodecHandler.INSTANCE);</span><br><span class="line">                        ch.pipeline().addLast(LoginAdapter.INSTANCE);</span><br><span class="line">                        ch.pipeline().addLast(LoginResponseHandler.INSTANCE);</span><br><span class="line">                        ch.pipeline().addLast(new ConfigRequestHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                //.option设置tcp底层相关属性，CONNECT_TIMEOUT_MILLIS表示连接时间，超过这个时间则连不上</span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, true);</span><br><span class="line">        return bootstrap.connect(host, port)</span><br><span class="line">                .addListener(new ChannelFutureListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                        if (future.isSuccess()) &#123;</span><br><span class="line">                            logger.info(&quot;连接成功&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            logger.error(future.cause().getMessage());</span><br><span class="line">                            logger.info(&quot;连接失败&quot;);</span><br><span class="line">                            future.channel().eventLoop().schedule(new Runnable() &#123;</span><br><span class="line">                                @Override</span><br><span class="line">                                public void run() &#123;</span><br><span class="line">                                    String serverAddress;</span><br><span class="line">                                    //优先遍历存在的节点</span><br><span class="line">                                    Set&lt;String&gt; dataAddressList =  ZKServiceDiscovery.dataAddressList;</span><br><span class="line">                                    if (!dataAddressList.isEmpty()) &#123;</span><br><span class="line">                                        serverAddress = provideServerAddress(dataAddressList);</span><br><span class="line">                                    &#125; else &#123;</span><br><span class="line">                                        //遍历不可使用的点，说不定就开启了。</span><br><span class="line">                                        Set&lt;String&gt; notUserAddressList = ZKServiceDiscovery.notUserAddressList;</span><br><span class="line">                                        serverAddress = provideServerAddress(notUserAddressList);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    ZKConstant.ZK_CURRENT_SERVER_NODE = serverAddress;</span><br><span class="line">                                    logger.info(&quot;serverAddress = &#123;&#125;&quot;, serverAddress);</span><br><span class="line">                                    if (!StringUtils.isEmpty(serverAddress)) &#123;</span><br><span class="line">                                        String[] addressArr = serverAddress.split(&quot;:&quot;);</span><br><span class="line">                                        if (addressArr != null &amp;&amp; addressArr.length &gt; 0) &#123;</span><br><span class="line">                                            connect(addressArr[0], Integer.parseInt(addressArr[1]));</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;, TIME_LOGIN, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).channel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 随机提供服务者的地址</span><br><span class="line">     *</span><br><span class="line">     * @param addressList</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String provideServerAddress(Set&lt;String&gt; addressList) &#123;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;(addressList);</span><br><span class="line">        String serverAddress = list.get(ThreadLocalRandom.current().nextInt(addressList.size()));</span><br><span class="line">        logger.info(&quot;随机 serverAddress = &#123;&#125;&quot;, serverAddress);</span><br><span class="line">        return serverAddress;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法介绍：<br>1、connect()方法，在connect()方法中，声明了workerGroup线程组以及bootstrap客户端启动类，在bootstrap配置workerGroup线程组、IO模型、一些底层的tcp相关属性，这里也不具体展开介绍了，大家可以结合代码的注释理解。主要介绍下bootstrap的handler()和connect()方法，handler()内元素定义了之后客户端向服务端发起的消息动作以及接受服务端回传的消息处理动作，具体的handler会在(客户端与服务端的通信)里面详细介绍。bootstrap的connect()方法则是客户端从zk中获取到服务端地址，然后尝试去连接服务端，并增加listener监听，如果发现未连接上，会从zk中随机再获取新的服务端地址，再尝试进行连接。<br>2、provideServerAddress()方法则是抽出来，用户客户端随机从服务端获取可用的地址。</p>
<h4 id="客户端与服务端的通信"><a href="#客户端与服务端的通信" class="headerlink" title="客户端与服务端的通信"></a>客户端与服务端的通信</h4><p>讲完了服务端、客户端各自的启动，接下来客户端与服务单的通信则是重头。通信时，需要注意的点有很多，将从以下几个方面完成对通信的理解：<br>1、客户端与服务端通信协议编解码;<br>2、通信信息的拆包粘包处理；<br>3、角色校验(例如日常的用户的登录);<br>4、校验通过完成自己所需的业务通信逻辑。<br>那么我们就开始一步步往下走吧</p>
<h5 id="一、客户端与服务端通信协议编解码"><a href="#一、客户端与服务端通信协议编解码" class="headerlink" title="一、客户端与服务端通信协议编解码"></a>一、客户端与服务端通信协议编解码</h5><p>所谓的通信协议，指的是客户端与服务端事先定义好规则，使得数据包每一段字节分表代表什么含义的规则。<br>规则设置如图所示：<br><img src="http://yunkai-wjd.oss-cn-beijing.aliyuncs.com/blog_netty_xieyi.png?Expires=1546246260&amp;OSSAccessKeyId=TMP.AQHv0OmkU7XCzkD8oC_XF35Ox5UTzZriu9ergiU9rBXOVze9-GW8UdXVSr0iMC4CFQDPbpufEaT4VrRcy-y92BO-QNwmzAIVALrOeUq8BgoDIt0yANMZoIHuc_78&amp;Signature=p%2BXaO4k6C6K4hr8komr%2FIgcvcNY%3D" alt="通信协议"><br>魔数：用于区别此数据包是否是否符合自定义的规范，如果不符合，可直接丢弃此数据包;<br>版本号：预留字段，协议升级的时候会用到，一般情况下是用不到的;<br>序列化算法：序列化算法会规定Java对象是如何转为二进制数据，同时如何把二进制数据转换成Java对象的;<br>指令：则会表示该用怎样的逻辑去处理这个数据包信息;<br>数据长度：则表示此数据包的长度;<br>数据：数据包的数据。</p>
<p>EncodeUtil类方法则是按照上面的通信协议，提供对数据编码/解码的方法。这里的packetMap以服务端为例，客户端则有对应的一份指令对应关系，在解码的时候会去判断此数据的指令是否提前声明，验证通过后才会将二进制数据转换成Java对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public class EncodeUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(EncodeUtil.class);</span><br><span class="line">    public static final int MAGIC_NUMBER = 0x12345678;</span><br><span class="line">    private static final Map&lt;Byte, Class&lt;? extends Packet&gt;&gt; packetMap;</span><br><span class="line">    private static final Map&lt;Byte, SerializerInterface&gt; serializerMap;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //请求pack</span><br><span class="line">        packetMap = new HashMap&lt;&gt;();</span><br><span class="line">        packetMap.put(CommandInterface.LOGIN_REQUEST, LoginRequestPacket.class);</span><br><span class="line">        packetMap.put(CommandInterface.HEART_REQUEST, HeartRequestPacket.class);</span><br><span class="line">        packetMap.put(CommandInterface.CLIENT_STOP_REQUEST, ClientStopRequestPacket.class);</span><br><span class="line"></span><br><span class="line">        serializerMap = new HashMap&lt;&gt;();</span><br><span class="line">        SerializerInterface serializerInterface = new JSONSerializerImpl();</span><br><span class="line">        serializerMap.put(SerializerAlgorithmInterface.JSON_ALGORITHM, serializerInterface);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 编码</span><br><span class="line">     *</span><br><span class="line">     * @param byteBuf</span><br><span class="line">     * @param packet</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static ByteBuf encode(ByteBuf byteBuf, Packet packet) &#123;</span><br><span class="line">        // 2. 序列化 Java 对象，这种方式很独特 SerializerInterface.DEFAULT</span><br><span class="line">        byte[] bytes = SerializerInterface.DEFAULT.serialize(packet);</span><br><span class="line">        // 3. 实际编码过程</span><br><span class="line">        byteBuf.writeInt(MAGIC_NUMBER);</span><br><span class="line">        byteBuf.writeByte(packet.getX_version());</span><br><span class="line">        byteBuf.writeByte(SerializerInterface.DEFAULT.getSerializerAlgorithm());</span><br><span class="line">        byteBuf.writeByte(packet.getCommand());</span><br><span class="line">        byteBuf.writeInt(bytes.length);</span><br><span class="line">        byteBuf.writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">        return byteBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解码</span><br><span class="line">     *</span><br><span class="line">     * @param byteBuf</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Packet decode(ByteBuf byteBuf) &#123;</span><br><span class="line">        //跳过部分如果需要验证，可自行处理的</span><br><span class="line">        //跳过魔数验证，4字节</span><br><span class="line">        byteBuf.skipBytes(4);</span><br><span class="line">        //跳过版本号验证，1子节</span><br><span class="line">        byteBuf.skipBytes(1);</span><br><span class="line">        //获取序列化算法标识</span><br><span class="line">        byte serializeAlgorithm = byteBuf.readByte();</span><br><span class="line">        // 指令</span><br><span class="line">        byte command = byteBuf.readByte();</span><br><span class="line">        //数据长度</span><br><span class="line">        int length = byteBuf.readInt();</span><br><span class="line">        //数据</span><br><span class="line">        byte[] bytes = new byte[length];</span><br><span class="line">        byteBuf.readBytes(bytes);</span><br><span class="line">        //验证指令和序列化算法</span><br><span class="line">        Class&lt;? extends Packet&gt; requestCommond = getRequestType(command);</span><br><span class="line">        SerializerInterface serializerInterface = getSerializer(serializeAlgorithm);</span><br><span class="line">        if (requestCommond != null &amp;&amp; serializerInterface != null) &#123;</span><br><span class="line">            return SerializerInterface.DEFAULT.deserialize(requestCommond, bytes);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.info(&quot;指令或者序列化算法不存在，请检查数据！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param serializeAlgorithm</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static SerializerInterface getSerializer(byte serializeAlgorithm) &#123;</span><br><span class="line">        return serializerMap.get(serializeAlgorithm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param command</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static Class&lt;? extends Packet&gt; getRequestType(byte command) &#123;</span><br><span class="line">        return packetMap.get(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="二、通信信息的拆包粘包处理"><a href="#二、通信信息的拆包粘包处理" class="headerlink" title="二、通信信息的拆包粘包处理"></a>二、通信信息的拆包粘包处理</h5><p>拆包、粘包其实是相对于粘包、半包现象的处理，那为什么会出现粘包、半包现象呢，虽然我们使用了Netty去处理，但是对于操作系统来讲，底层只认TCP协议，客户端在Netty应用层按照ByteBuf为单位发送数据，但到了操作系统底层后仍然是以字节流发送数据，数据到了服务端也按照字节流的方式读入，数据到了Netty应用层重新再拼装成ByteBuf，此时服务端接收的ByteBuf可能与客户端发出的ByteBuf是不对等，从而出现了粘包和半包的现象。<br>注：Netty在数据传输中是以ByteBuf为单位进行发送和接收的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Spliter extends LengthFieldBasedFrameDecoder&#123;</span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(Spliter.class);</span><br><span class="line">    /**</span><br><span class="line">     * 长度域偏移量</span><br><span class="line">     */</span><br><span class="line">    private static final int LENGTH_FIELD_OFFSET = 7;</span><br><span class="line">    /**</span><br><span class="line">     * 长度域长度</span><br><span class="line">     */</span><br><span class="line">    private static final int LENGTH_FIELD_LENGTH = 4;</span><br><span class="line">    public Spliter() &#123;</span><br><span class="line">        super(Integer.MAX_VALUE, LENGTH_FIELD_OFFSET, LENGTH_FIELD_LENGTH);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception &#123;</span><br><span class="line">        //屏蔽非法消息，判断魔数</span><br><span class="line">        if (in.getInt(in.readerIndex()) != EncodeUtil.MAGIC_NUMBER) &#123;</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.decode(ctx, in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spliter类就可以作为我们的拆包器，继承了LengthFieldBasedFrameDecoder类，LengthFieldBasedFrameDecoder类是基于长度域拆包器，可根据自定义协议中的规则长度进行处理，例如类中的长度域偏移量和长度域长度都是基于我们之前定义的规则，7=4+1+1+，而4，则表示为数据的长度。同时，重写了decode()方法，在完成拆包后，会去校验数据包前4个字节，判断是否符合魔数。</p>
<h5 id="三、角色校验"><a href="#三、角色校验" class="headerlink" title="三、角色校验"></a>三、角色校验</h5><p>介绍了客户端与服务端通信协议编解码和通信信息的拆包粘包处理，大家应该还有个疑惑，在编解码中只是介绍了编解码的方法，但是并没有具体讲到如何去使用，在角色校验前，我先介绍下编解码的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class PacketCodecHandler extends MessageToMessageCodec&lt;ByteBuf, Packet&gt; &#123;</span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(PacketCodecHandler.class);</span><br><span class="line">    public static final PacketCodecHandler INSTANCE = new PacketCodecHandler();</span><br><span class="line">    /**</span><br><span class="line">     * 加密</span><br><span class="line">     *</span><br><span class="line">     * @param channelHandlerContext</span><br><span class="line">     * @param packet</span><br><span class="line">     * @param list</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void encode(ChannelHandlerContext channelHandlerContext, Packet packet, List&lt;Object&gt; list) throws Exception &#123;</span><br><span class="line">        ByteBuf buf = channelHandlerContext.alloc().buffer();</span><br><span class="line">        EncodeUtil.encode(buf, packet);</span><br><span class="line">        list.add(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 解密</span><br><span class="line">     *</span><br><span class="line">     * @param channelHandlerContext</span><br><span class="line">     * @param buf</span><br><span class="line">     * @param list</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf buf, List&lt;Object&gt; list) throws Exception &#123;</span><br><span class="line">        list.add(EncodeUtil.decode(buf));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编解码时，同样借助了Netty自身的MessageToMessageCodec类，保证了每次发出/接受消息时，都能走对应编码/解码的逻辑。这也是Netty的强大之处，提供了许许多多的基础类能够完成我们各种业务需求。<br>解释了如何去使用解码和编码，那么就开始介绍角色登录校验喽</p>
<p><strong>客户端：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class LoginAdapter extends ChannelInboundHandlerAdapter&#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(LoginAdapter.class);</span><br><span class="line"></span><br><span class="line">    public static final LoginAdapter INSTANCE = new LoginAdapter();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        LoginRequestPacket packet = new LoginRequestPacket();</span><br><span class="line">        String applicationName = EnvProperties.applicationName;</span><br><span class="line">        String applicationPassword = EnvProperties.applicationPassword;</span><br><span class="line">        packet.setUsername(applicationName);</span><br><span class="line">        packet.setPassword(applicationPassword);</span><br><span class="line">        ctx.writeAndFlush(packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ChannelInboundHandlerAdapter是ChannelInboundHandler子类，ChannelInboundHandler是处理读数据的逻辑，这里主要借助了它的channelActive方法，当客户端连接成功服务端后，就会调用此方法，从而把登录信息发送给服务端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务端：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class LoginRequestHandler extends SimpleChannelInboundHandler&lt;LoginRequestPacket&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(LoginRequestHandler.class);</span><br><span class="line"></span><br><span class="line">    public static final LoginRequestHandler INSTANCE = new LoginRequestHandler();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext channelHandlerContext, LoginRequestPacket loginRequestPacket) throws Exception &#123;</span><br><span class="line">        //返回packet</span><br><span class="line">        LoginResponsePacket loginResponsePacket = new LoginResponsePacket();</span><br><span class="line">        if (vail(loginRequestPacket)) &#123;</span><br><span class="line">            String userId = UUID.randomUUID().toString();</span><br><span class="line">            logger.info(&quot;用户: &#123;&#125;, 开始登录，Id为: &#123;&#125;&quot;, loginRequestPacket.getUsername(), userId);</span><br><span class="line">            loginResponsePacket.setUserId(userId);</span><br><span class="line">            loginResponsePacket.setName(loginRequestPacket.getUsername());</span><br><span class="line">            loginResponsePacket.setSucess(true);</span><br><span class="line">            SessionUtil.channelGroup.add(channelHandlerContext.channel());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            loginResponsePacket.setSucess(false);</span><br><span class="line">            loginResponsePacket.setMessage(&quot;用户名或者密码错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        channelHandlerContext.channel().writeAndFlush(loginResponsePacket);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证登录</span><br><span class="line">     *</span><br><span class="line">     * @param loginRequestPacket</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private boolean vail(LoginRequestPacket loginRequestPacket) &#123;</span><br><span class="line">        if (EnvProperties.applicationPassword.equals(loginRequestPacket.getPassword())) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SimpleChannelInboundHandler是Netty基于简化二进制流转化为java对象的抽象考虑，继承此类，在解码后得到的Java对象，SimpleChannelInboundHandler类自动会帮我们判断和传递对象进入哪个handler进行处理，同时SimpleChannelInboundHandler也是继承ChannelInboundHandler，channelRead0()方法会处理收到客户端发送到饿消息，在服务端收到信息后，校验登录，如果校验通过，则在SessionUtil中把此客户端信息保存下来，以便下次给指定客户端发送消息，同时发送个消息给客户端，表示登录成功。</p>
<p><strong>客户端：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class LoginResponseHandler extends SimpleChannelInboundHandler&lt;LoginResponsePacket&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(LoginResponseHandler.class);</span><br><span class="line"></span><br><span class="line">    public static final LoginResponseHandler INSTANCE = new LoginResponseHandler();</span><br><span class="line"></span><br><span class="line">    private static final int HEARTBEAT_INTERVAL = 5;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext channelHandlerContext, LoginResponsePacket loginResponsePacket) throws Exception &#123;</span><br><span class="line">        if (loginResponsePacket.getSucess()) &#123;</span><br><span class="line">            logger.info(&quot;用户Id: &#123;&#125;, 登录成功&quot;, loginResponsePacket.getUserId());</span><br><span class="line">            EnvProperties.applicationId = loginResponsePacket.getUserId();</span><br><span class="line">            SessionUtil.addMapUser(new UserDo(loginResponsePacket.getUserId(), loginResponsePacket.getName()), channelHandlerContext.channel());</span><br><span class="line">            //登录成功后，定时发送心跳</span><br><span class="line">            scheduleSendHeartBeat(channelHandlerContext);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.info(&quot;时间: &#123;&#125;, 登录失败，失败原因: &#123;&#125;&quot;, new Date(), loginResponsePacket.getMessage());</span><br><span class="line">            channelHandlerContext.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 定时发送心跳</span><br><span class="line">     *</span><br><span class="line">     * @param ctx</span><br><span class="line">     */</span><br><span class="line">    private void scheduleSendHeartBeat(ChannelHandlerContext ctx) &#123;</span><br><span class="line">        ctx.executor().schedule(() -&gt; &#123;</span><br><span class="line">            if (ctx.channel().isActive()) &#123;</span><br><span class="line">                logger.info(&quot;客户端发了一个心跳&quot;);</span><br><span class="line">                ctx.writeAndFlush(new HeartRequestPacket());</span><br><span class="line">                scheduleSendHeartBeat(ctx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, HEARTBEAT_INTERVAL, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端在服务端发送消息后，如果收到的是登录成功的消息，同样也会将此Channel保存在SessionUtil中，相信童鞋们已经留意到scheduleSendHeartBeat()方法，定时发送心跳方法，这个会在最后一段维护/断开客户端与服务端通信中具体介绍。</p>
<p>完成上面逻辑后，如果客户端和服务端校验通过后，则可以处理接下来自己定义的业务了。</p>
<h5 id="四、校验通过完成自己所需的业务通信逻辑"><a href="#四、校验通过完成自己所需的业务通信逻辑" class="headerlink" title="四、校验通过完成自己所需的业务通信逻辑"></a>四、校验通过完成自己所需的业务通信逻辑</h5><p>这部分其实跟用户登录校验的实现逻辑类似，实现的步骤：定义各自的Request和Response的Packet，同时创建对应的指令，把指令放入对应的map中，然后根据业务场景存储对应传递的消息值，这里就不贴代码了哈。</p>
<h4 id="维护-断开客户端与服务端通信"><a href="#维护-断开客户端与服务端通信" class="headerlink" title="维护/断开客户端与服务端通信"></a>维护/断开客户端与服务端通信</h4><p>以上已经讲完了客户端和服务端建立连接以及消息的发送和接收，那么实际的场景肯定会存在，此客户端发送完消息后，在接下来一段时间后都不会有消息往来，那么是否可以定义在指定时间内，如果消息传递，就把此链接关闭，以起到节省资源的目的。当然也会存在说，强制需要保证此连接建立的情况，那么接下去就会去介绍如何去实现这两个场景需求。</p>
<p><strong>心跳检测：</strong></p>
<p>这个其实在上面的时候已经出现过，就是定时发送心跳的方法，我们会声明心跳的Request和Response的Packet，并设置在定时器，定时向服务端发送消息，当然这个时间一般为下面提到的空闲检测时间的三分之一。</p>
<p><strong>检测空闲时间：</strong></p>
<p>空闲检测指的是每隔一段时间，检测这段时间内是否有数据读写，简化一下，我们的服务端只需要检测一段时间内，是否收到过客户端发来的数据即可，Netty 自带的 IdleStateHandler 就可以实现这个功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class IMIdleStateHandler extends IdleStateHandler&#123;</span><br><span class="line"></span><br><span class="line">    private static Logger logger = LoggerFactory.getLogger(IMIdleStateHandler.class);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 空闲时间</span><br><span class="line">     */</span><br><span class="line">    private static final int TIME_DE = 15;</span><br><span class="line"></span><br><span class="line">    public IMIdleStateHandler() &#123;</span><br><span class="line">        super(TIME_DE, 0, 0, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) &#123;</span><br><span class="line">        logger.info(&quot;&#123;&#125; 秒内未读取到数据，关闭连接&quot;, TIME_DE);</span><br><span class="line">        ctx.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IMIdleStateHandler类继承了IdleStateHandler类，保证说，如果客户端在15s内未向服务端发送消息，则服务端会调用channelIdle()方法，从而关闭此链接。</p>
<h4 id="知识点介绍-copy于大神整理的语言"><a href="#知识点介绍-copy于大神整理的语言" class="headerlink" title="知识点介绍(copy于大神整理的语言)"></a>知识点介绍(copy于大神整理的语言)</h4><h5 id="OutBoundHandler、InboundHandler"><a href="#OutBoundHandler、InboundHandler" class="headerlink" title="OutBoundHandler、InboundHandler"></a>OutBoundHandler、InboundHandler</h5><p>Netty中pipeline 与 channelHandler 的构成</p>
<p><img src="http://yunkai-wjd.oss-cn-beijing.aliyuncs.com/blog_pie_handler.jpg?Expires=1546251181&amp;OSSAccessKeyId=TMP.AQHv0OmkU7XCzkD8oC_XF35Ox5UTzZriu9ergiU9rBXOVze9-GW8UdXVSr0iMC4CFQDPbpufEaT4VrRcy-y92BO-QNwmzAIVALrOeUq8BgoDIt0yANMZoIHuc_78&amp;Signature=2V8BSpmm2ua6YfbaLj1Pcy5IJ38%3D" alt="pipe"></p>
<p>无论是从服务端来看，还是客户端来看，在 Netty 整个框架里面，一条连接对应着一个 Channel，这条 Channel 所有的处理逻辑都在一个叫做 ChannelPipeline 的对象里面，ChannelPipeline 是一个双向链表结构，他和 Channel 之间是一对一的关系。</p>
<p>ChannelPipeline 里面每个节点都是一个 ChannelHandlerContext 对象，这个对象能够拿到和 Channel 相关的所有的上下文信息，然后这个对象包着一个重要的对象，那就是逻辑处理器 ChannelHandler。</p>
<p>所以我们在服务端的childHandler()方法和客户端handler()方法内注册的其实都是一个个ChannelHandler，从而把相关的逻辑串联起来。(这个是个人理解哦)</p>
<p>ChannelHandler的分类，ChannelHandler有两大子接口：ChannelInboundHandler和ChannelOutBoundHandler，ChannelInboundHandler是处理读逻辑，处理读到的数据，数据对象会一层层传递，当然前提是传递的对象满足ChannelHandler中声明对象类型。ChannelOutBoundHandler是处理写逻辑，同样也会逐层处理对象，当然也存在满足对象类型的条件。<br>ChannelInboundHandler和ChannelOutBoundHandler在服务端childHandler()和客户端handler()执行顺序和写的顺序有关系哦，ChannelInboundHandler是写在前面的优先执行而ChannelOutBoundHandler则刚好相反。</p>
<h5 id="ChannelHandler的生命周期"><a href="#ChannelHandler的生命周期" class="headerlink" title="ChannelHandler的生命周期"></a>ChannelHandler的生命周期</h5><p>1、handlerAdded() ：表示在当前的 channel 中，已经成功添加了一个 handler 处理器;<br>2、channelRegistered()：这个回调方法，表示当前的 channel 的所有的逻辑处理已经和某个 NIO 线程建立了绑定关系;<br>3、channelActive()：当 channel 的所有的业务逻辑链准备完毕（也就是说 channel 的 pipeline 中已经添加完所有的 handler）以及绑定好一个 NIO 线程之后，这条连接算是真正激活了，接下来就会回调到此方法。<br>4、channelRead()：客户端向服务端发来数据，每次都会回调此方法，表示有数据可读。<br>5、channelReadComplete()：服务端每次读完一次完整的数据之后，回调该方法，表示数据读取完毕。<br>6、channelInactive(): 表面这条连接已经被关闭了，这条连接在 TCP 层面已经不再是 ESTABLISH 状态了<br>7、channelUnregistered(): 既然连接已经被关闭，那么与这条连接绑定的线程就不需要对这条连接负责了，这个回调就表明与这条连接对应的 NIO 线程移除掉对这条连接的处理<br>8、handlerRemoved()：最后，我们给这条连接上添加的所有的业务逻辑处理器都给移除掉。</p>
<h5 id="ChannelHandlerContext-writeAndFlush-和ChannelHandlerContext-channel-writeAndFlush-方法区别"><a href="#ChannelHandlerContext-writeAndFlush-和ChannelHandlerContext-channel-writeAndFlush-方法区别" class="headerlink" title="ChannelHandlerContext.writeAndFlush()和ChannelHandlerContext.channel().writeAndFlush()方法区别"></a>ChannelHandlerContext.writeAndFlush()和ChannelHandlerContext.channel().writeAndFlush()方法区别</h5><p>调用 ctx.writeAndFlush() 可以直接一口气把对象送到 codec 中编码，然后写出去，即无需再经过其他的outBound。<br>ctx.channel().writeAndFlush() 是从 pipeline 链中的最后一个 outBound 类型的 handler 开始，把对象往前进行传播，如果你确认当前创建的对象需要经过后面的 outBound 类型的 handler，那么就调用此方法。<br>ctx.channel().writeAndFlush()，对象会从最后一个 outBound 类型的 handler 开始，逐个往前进行传播，路径是要比 ctx.writeAndFlush() 要长的。</p>
<h5 id="ChannelHandler-Sharable"><a href="#ChannelHandler-Sharable" class="headerlink" title="@ChannelHandler.Sharable"></a>@ChannelHandler.Sharable</h5><p>@ChannelHandler.Sharable 是Netty提供的注解，显示地告诉 Netty，这个 handler 是支持多个 channel 共享的，否则会报错。当所有的链接所处理的逻辑是抑制时，可以把此Handler加上这个注释，那么每个Handler就无需在New，节省了一定的内存。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>云开也是之前购买了掘金_闪电侠大佬的《Netty 入门与实战：仿写微信 IM 即时通讯系统》，由于在小册中大佬讲的很详细，云开想在一篇博客中介绍完全显然是不可能的，写这篇博客也是自己想对学习结果的总结，距离学习结束也有几个月时间了，有些点温故了遍小册才找到了感觉，大家如果觉得讲得不对的地方可以加我微信告知我哈，微信号：wjd_632479475，如果想更具体了解下Netty可以点我下面的Links，里面是掘金小测的地址哦。</p>
<p>最后祝大家新年快乐，2019年心想事成。<br>                                            2018_12_31  云开</p>
<p>附：<a href="https://github.com/JiongJiongGe/netty.server" target="_blank" rel="noopener">GitHub项目链接地址_服务端</a><br><a href="https://github.com/JiongJiongGe/netty.client" target="_blank" rel="noopener">GitHub项目链接地址_客户端</a></p>
<p>Links：<br><a href="https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b6a1a9cf265da0f87595521" target="_blank" rel="noopener">掘金闪电侠小册链接</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/SpringBoot/">SpringBoot</a><a href="/tags/Netty/">Netty</a><a href="/tags/NIO/">NIO</a>
    </span>
    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 云开
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>