<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | 守得云开见月明 | 在IT海洋打滚的小🐳</title>

  
  <meta name="author" content="云开">
  

  
  <meta name="description" content="在IT海洋打滚的小🐳">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="守得云开见月明"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="守得云开见月明" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">守得云开见月明</a>
    </h1>
    <p class="site-description">在IT海洋打滚的小🐳</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2017/12/03/yunkai_redbag_example_one/"><span>抢红包实现方案</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/12/03/yunkai_redbag_example_one/" rel="bookmark">
        <time class="entry-date published" datetime="2017-12-03T03:53:10.000Z">
          2017-12-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>好久不见，甚是想念</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>redis是一个开源的、内存存储的数据结构服务器，可用作数据库、高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合等数据类型。<br>jedis则集成了redis的一些命令操作，封装了redis的java客户端，并提供了连接池管理，可以操作redis数据库。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>之所以说redis是内存数据库，是因为redis基于内存的读取和写入，相比传统的数据库基于磁盘IO快上数倍。于是乎redis在现在的应用中使用非常广泛，例如：<br>1、提供缓存服务，存储访问频率高的热数据防止穿透数据库；
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/redis/">redis</a><a href="/tags/jedis/">jedis</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/10/29/yunkai_singleton/"><span>单例避免多线程同时修改同个值从而造成脏数据</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/10/29/yunkai_singleton/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-29T05:44:10.000Z">
          2017-10-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式是一种常用的软件设计模式。单例可以保证系统中一个类只有一个实例，即一个类只有一个对象实例。<br>优点：<br>&nbsp;&nbsp;&nbsp;(1)、实例控制<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例会阻止其他对象实例化其自己的对象副本，从而确保所有对象都访问唯一实例。<br>&nbsp;&nbsp;&nbsp;(2)、节约系统资源<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于系统内存中只存在一个对象，因此可以节约对象频繁创建和销毁。
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/singleton/">singleton</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/10/13/yunkai_hessian/"><span>Hessian远程调用服务实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/10/13/yunkai_hessian/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-13T10:48:10.000Z">
          2017-10-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Hessian调用是基于HTTP的轻量级远程服务调用，提供了较轻量的方法实现了RMI(远程方法调用)的功能，与WebService相比，Hessian更简单、快捷。Hessian采用了二进制协议，因此它更适合于发送二进制数据。往简单了说，Hessian支持提供自定义API接口方法供工程间的远程调用。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>举个例子来说，因业务需求需要，开发了A和B两个系统，基本上所有与用户相关的都在A系统中，其中就有个添加用户的方法。当B系统要实现添加用户的需求时，有一个简单粗暴的方法，就是把A系统中添加用户的方法一摸一样拷贝一份到B系统，这样的弊端相信大家都深有体会，就是以后维护此方法时，需要同时维护两个系统的功能代码。
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/hessian/">hessian</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/09/15/yunkai_mysql_read_write/"><span>mysql实现读写分离</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/15/yunkai_mysql_read_write/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-15T14:48:10.000Z">
          2017-09-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://jiongjiongge.github.io/2017/09/08/yunkai_mysql_master_slave/#more" target="_blank" rel="noopener">mysql单机配置多实例子后实现mysql主从复制</a>此篇中已经提到mysql主从复制和读写分离的概念和应用场景，并且告诉大家如何去实现mysql的主从复制，这也为我们今天要开展的mysql读写分离提供了数据一致性的服务。那么，话不多说，开始我们今天的实践之旅。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>JDK 1.8.0_131、MAVEN apache-maven-3.5.0</p>
<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>SpringBoot、Mybatis、Mysql<br>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/mysql/">mysql</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/09/08/yunkai_mysql_master_slave/"><span>mysql单机配置多实例子后实现mysql主从复制</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/08/yunkai_mysql_master_slave/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-08T13:48:10.000Z">
          2017-09-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>Mysql主从复制</strong>：指的是Mysql从服务器(Slave)从主Mysql主服务器(Master)同步数据，更具体的说是Slave从Master的二进制日志(bin_log)中读取事件，保存在Slave的中继日志(relay_log)中，然后Slave再从中继日志中读取出来再执行一遍。<br><strong>Mysql读写分离</strong>：指的是对Mysql的写入操作(update、insert)和读取操作(select)分开，分别由不同的服务器负责，一般是Mater负责写，Slave负责读，且一般是配置一写多读(当然这个不是唯一的方式，可以根据场景配置)。
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/mysql/">mysql</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/08/26/yunkai_springboot_rabbit_handle_reply/"><span>springboot实现rabbitmq消息队列_ACK手动确认机制</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/08/26/yunkai_springboot_rabbit_handle_reply/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-26T06:55:10.000Z">
          2017-08-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://jiongjiongge.github.io/2017/08/13/yunkai_springboot_rabbit_no_reply/#more" target="_blank" rel="noopener">springboot实现rabbitmq消息队列_ACK自动确认机制</a>中已经提过rabbitMQ的概念和应用场景，这边就不再详细介绍。由于ACK自动确认机制无法记录未进入Exchange交互机时产生错误的消息信息，因此在本篇中小🐳将介绍ACK手动确认机制，来保证在rabbitMQ在处理消息的准确性。</p>
<p>当然有利必有弊，使用事务机制有2个缺点：<br>1、消息处理速度慢<br>2、如果消息确认的不当，容易造成消息的阻塞</p>
<p>相信有的童鞋已经蠢蠢欲动，那么让我们开始探索之旅吧。因考虑到有些童鞋是第一次看到小🐳写的rabbitMQ，所以实践还是从头开始，已经看过小🐳写的ACK自动确认机制的童鞋，需留意过程中的注意点。
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/springboot/">springboot</a><a href="/tags/rabbitmq/">rabbitmq</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/08/13/yunkai_springboot_rabbit_no_reply/"><span>springboot实现rabbitmq消息队列_ACK自动确认机制</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/08/13/yunkai_springboot_rabbit_no_reply/" rel="bookmark">
        <time class="entry-date published" datetime="2017-08-13T12:55:10.000Z">
          2017-08-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>AMQP，即Advanced Message Queuing Protocol，是应用层标准高级消息队列协议，同时也是应用层协议的一个开发标准，为面向消息的中间件设计，主要作用于组件间的消息解耦，消息的发送者只需发送消息源而无需知道消息使用者的存在。<br>RabbitMQ，基于Erlang语言编写，是一个开源的AMQP实现，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。RabbitMQ中间件分为服务端和客户端，服务端可以理解为是消息的代理消费者，客户端有分为消息生产者和消息消费者。
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/springboot/">springboot</a><a href="/tags/rabbitmq/">rabbitmq</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/24/welcome/"><span>welcome  奋斗</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/24/welcome/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-24T01:44:20.000Z">
          2017-07-24
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>欢迎来到我的个人技术博客，感谢你花时间与我共度此次海洋旅途。<br>希望大家针对文章中的知识点，如果有遗漏、不准确的点或者学习方向的偏离，指点小🐳，及时回归正轨。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/导航篇/">导航篇</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/" class="pagination-prev">上一页</a>
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 云开
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>