<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>守得云开见月明</title>

  
  <meta name="author" content="云开">
  

  
  <meta name="description" content="在IT海洋打滚的小🐳">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="守得云开见月明"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="守得云开见月明" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">守得云开见月明</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/tags">标签</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/03/17/yunkai_executor_future/"><span>借助于线程池的Executor框架+Future 实现并发编程</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/03/17/yunkai_executor_future/" rel="bookmark">
        <time class="entry-date published" datetime="2018-03-17T14:18:15.000Z">
          2018-03-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>关于线程方面，请教了公司的大🐮，大🐮给小🐳抛了一些点，小🐳听了后，感觉一时半会找不到大海的方向，最后大🐮让我先了解四个概念：同步、异步、阻塞以及非阻塞。接下来谈谈我对这四个概念的理解，如有不恰当的地方希望大家指正。<br><strong>线程同步</strong>：线程之间存在着相互依赖的关系，前一个线程的输出结果将作为后一个线程的输入，当前一个线程没有输出时，后一个线程必须等待，即由调用者主动等待这个调用的结果。
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Executor/">Executor</a><a href="/tags/Future/">Future</a><a href="/tags/线程/">线程</a><a href="/tags/springboot/">springboot</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/02/10/yunkai_dubbo/"><span>Dubbo 服务提供方、消费方</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/02/10/yunkai_dubbo/" rel="bookmark">
        <time class="entry-date published" datetime="2018-02-09T23:35:20.000Z">
          2018-02-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在实际的软件开发中，随着业务的逐步增长，软件对应的服务应用也会逐渐增多，应用之间交互不可避免，这时如果条件允许，则需要将不同的功能模块单独抽取出来，作为独立的服务，部署，并向外提供对应可用的接口。<br><a href="https://jiongjiongge.github.io/2018/01/25/yunkai_distributed/#more" target="_blank" rel="noopener">服务间调用，保证数据的正确性</a>中介绍了Hessian的RPC远程服务调用方式，并考虑了服务的正确性，在此篇中则介绍一种RPC框架——Dubbo。<br>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Dubbo/">Dubbo</a><a href="/tags/Zookeeper/">Zookeeper</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/01/25/yunkai_distributed/"><span>服务间调用，保证数据的正确性</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/01/25/yunkai_distributed/" rel="bookmark">
        <time class="entry-date published" datetime="2018-01-25T13:51:10.000Z">
          2018-01-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在实际的开发中，我们往往会将一个大的系统划分为多个业务模块，这些模块可能部署在相同的机器上，也可能部署在不同的机器上，各个业务模块之间通过接口进行数据交互，通常接口间的访问通过RPC(远程过程调用)的方式。<br>但在实际场景中，调用者调用服务(以下称被调用者)的新增/修改数据接口成功后，返回到调用者，若在调用者后续业务逻辑中出现错误，必须将被调用者的数据回滚，从而保证数据的正确性。然而由于此流程并非在同一个事务中，故需增加额外的操作来保证，这就是此篇的由来。<br>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Hessian/">Hessian</a><a href="/tags/Rabbitmq/">Rabbitmq</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/01/08/yunkai_aop_application/"><span>Spring之AOP应用场景(二)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/01/08/yunkai_aop_application/" rel="bookmark">
        <time class="entry-date published" datetime="2018-01-07T16:59:59.000Z">
          2018-01-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在上篇中，已经介绍了AOP的基本名词和配置，同时也了解了AOP在打印日志信息的应用。云开为了履行对大🐮的承诺，继续调研AOP在其他场景下的应用，以下几点是调研结果，稍后会为童鞋们详细介绍：<br>1、HTTP接口鉴权；<br>2、方法耗时统计。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>云开：大🐮，我调研到了AOP还有以下两个应用场景：HTTP接口鉴权和方法耗时统计。<br>大🐮：好，那你给我介绍介绍。<br>云开：好的，那我一个个描述给你听。<br>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/aop/">aop</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/01/01/yunkai_aop/"><span>Spring之AOP介绍</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/01/01/yunkai_aop/" rel="bookmark">
        <time class="entry-date published" datetime="2018-01-01T02:51:10.000Z">
          2018-01-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>AOP即Aspect Oriented Programming。它利用一种称为”横切”的技术，将那些影响多个类公众行为封装到一个可重用模块中，并将其称为“Aspect”，即切面。切面，简单说就是那些与业务无关，却将业务模块所公同调用的逻辑封装起来，便于减少系统的重复代码，降低模块间的耦合度，有利于之后的扩展和维护。</p>
<p>AOP将程序系统代码模块分为两个部分：核心关注点和横切关注点。核心关注点主要与业务处理相关，而横切关注点经常发生在核心关注点的多处，比如日志的打印(日志打印Controller请求的接口地址、方式以及参数)。AOP的作用在于分离系统中的各种关注点，并将核心关注点和横切关注点分离开。<br>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/aop/">aop</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/12/23/yunkai_thread_executor/"><span>群发消息多线程的应用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/12/23/yunkai_thread_executor/" rel="bookmark">
        <time class="entry-date published" datetime="2017-12-23T02:51:10.000Z">
          2017-12-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>多线程使得程序内部可以分出多个线程来做多件事情，从而加快程序执行、处理速度。用多线程的目的主要是为了更好的利用CPU资源。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>大🐮：云开，我发现我们公司群发送券的执行效率还有提高的空间，有机会去改改？<br>云开：好呀好呀，我去看看。<br>云开：大🐮，我看了之前的代码，我觉得可以在群发这个动作上加上多线程，这样可以加快群发的执行，从而减少程序执行时间。<br>大🐮：好，那按你的想法去改进吧。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在本篇中，我以给用户群发信息来模拟在我司改造群发送券的场景。<br>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/ThreadPoolExecutor/">ThreadPoolExecutor</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/12/03/yunkai_redbag_example_one/"><span>抢红包实现方案</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/12/03/yunkai_redbag_example_one/" rel="bookmark">
        <time class="entry-date published" datetime="2017-12-03T03:53:10.000Z">
          2017-12-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>好久不见，甚是想念</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>redis是一个开源的、内存存储的数据结构服务器，可用作数据库、高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合等数据类型。<br>jedis则集成了redis的一些命令操作，封装了redis的java客户端，并提供了连接池管理，可以操作redis数据库。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>之所以说redis是内存数据库，是因为redis基于内存的读取和写入，相比传统的数据库基于磁盘IO快上数倍。于是乎redis在现在的应用中使用非常广泛，例如：<br>1、提供缓存服务，存储访问频率高的热数据防止穿透数据库；
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/redis/">redis</a><a href="/tags/jedis/">jedis</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/10/29/yunkai_singleton/"><span>单例避免多线程同时修改同个值从而造成脏数据</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/10/29/yunkai_singleton/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-29T05:44:10.000Z">
          2017-10-29
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>单例模式是一种常用的软件设计模式。单例可以保证系统中一个类只有一个实例，即一个类只有一个对象实例。<br>优点：<br>&nbsp;&nbsp;&nbsp;(1)、实例控制<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例会阻止其他对象实例化其自己的对象副本，从而确保所有对象都访问唯一实例。<br>&nbsp;&nbsp;&nbsp;(2)、节约系统资源<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于系统内存中只存在一个对象，因此可以节约对象频繁创建和销毁。
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/singleton/">singleton</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/10/13/yunkai_hessian/"><span>Hessian远程调用服务实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/10/13/yunkai_hessian/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-13T10:48:10.000Z">
          2017-10-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Hessian调用是基于HTTP的轻量级远程服务调用，提供了较轻量的方法实现了RMI(远程方法调用)的功能，与WebService相比，Hessian更简单、快捷。Hessian采用了二进制协议，因此它更适合于发送二进制数据。往简单了说，Hessian支持提供自定义API接口方法供工程间的远程调用。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>举个例子来说，因业务需求需要，开发了A和B两个系统，基本上所有与用户相关的都在A系统中，其中就有个添加用户的方法。当B系统要实现添加用户的需求时，有一个简单粗暴的方法，就是把A系统中添加用户的方法一摸一样拷贝一份到B系统，这样的弊端相信大家都深有体会，就是以后维护此方法时，需要同时维护两个系统的功能代码。
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/hessian/">hessian</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/09/15/yunkai_mysql_read_write/"><span>mysql实现读写分离</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/15/yunkai_mysql_read_write/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-15T14:48:10.000Z">
          2017-09-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://jiongjiongge.github.io/2017/09/08/yunkai_mysql_master_slave/#more" target="_blank" rel="noopener">mysql单机配置多实例子后实现mysql主从复制</a>此篇中已经提到mysql主从复制和读写分离的概念和应用场景，并且告诉大家如何去实现mysql的主从复制，这也为我们今天要开展的mysql读写分离提供了数据一致性的服务。那么，话不多说，开始我们今天的实践之旅。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>JDK 1.8.0_131、MAVEN apache-maven-3.5.0</p>
<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>SpringBoot、Mybatis、Mysql<br>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/mysql/">mysql</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 云开
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>